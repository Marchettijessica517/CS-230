# CS-230
The Gaming Room client sought to expand their already successful Draw It or Lose It game from its existing Android-only platform into a fully cross-platform application. The goal was to provide users with the ability to access the game on multiple platforms while maintaining consistency and reliability in gameplay. Several key requirements were outlined. Each game and team name needed to be unique, ensuring clarity and preventing duplication errors during play. The software also needed to support multiple players per team, with flexibility to run either single- or multi-team matches. Another critical requirement was that only one instance of the game could exist in memory at any given time, preventing conflicts and ensuring stability in execution. In addition, the client requested assistance with setting up the development environment and improving workflow efficiency, so the project could scale smoothly as new platforms were added.

When developing the documentation for this project, one area where I particularly excelled was the evaluations section. My instructor specifically noted that I exceeded expectations in how I expressed my assessments and evaluations of different approaches. I attribute this success to my ability to think critically about trade-offs and clearly explain the rationale behind technical decisions. Strong evaluation is an essential part of design documentation, since it not only provides justification for specific choices but also helps project stakeholders understand the reasoning behind them. This transparency builds trust with the client and offers the development team a clear foundation for implementation.

Working through the design document itself was an incredibly valuable process. For someone like me, who has a tendency to overdocument, the structured template was extremely helpful. It ensured that I focused only on necessary requirements and avoided cluttering the document with excess details that might overwhelm readers or distract from the core objectives. By following a clear, straightforward structure, I was able to deliver a concise yet comprehensive plan that addressed the client’s needs. This process reinforced the importance of organization in technical documentation and showed me that structure can improve both clarity and efficiency.

If I were to revise the document, I would incorporate pseudocode into the template. While pseudocode has often been a source of frustration for me in the past, I have recently come to appreciate its practical benefits, especially in larger projects. Including pseudocode would give all team members—both technical and non-technical—a clearer understanding of how the application logic will flow. This could help identify potential challenges earlier in the process, allow developers to better estimate the time and resources needed, and make it easier to assign tasks based on team members’ skillsets. Adding pseudocode would ultimately elevate the documentation by bridging the gap between high-level design and detailed implementation.

Another area where I felt confident was in translating the client’s needs into technical requirements. I view this as one of the most critical skills in software design and consulting. Often, clients know what they want in terms of outcomes but do not have the technical vocabulary to describe how those outcomes should be achieved. This is where the role of the designer becomes that of both translator and liaison, ensuring that the client’s expectations are clearly expressed in terms the development team can act upon. Without this translation process, miscommunication and misalignment are almost inevitable, leading to products that fail to meet expectations. By carefully listening to the client, clarifying their goals, and mapping them into actionable requirements, I was able to ensure that the project stayed aligned with the client’s vision while also being technically feasible.

My approach to designing software is grounded in research and preparation. I make it a point to thoroughly review documentation, methodologies, and case studies before beginning any large project. While this upfront work can feel tedious and time-consuming, it pays off by reducing errors, avoiding rework, and ultimately saving both time and resources. I prefer to break projects into smaller, more manageable pieces, allowing me to focus on one component at a time without losing sight of the larger system. Incorporating Agile-inspired strategies also helps me remain flexible, since it supports iterative progress, regular feedback, and continuous improvement. This balance between detailed planning and adaptive execution has proven to be my most effective strategy for tackling software design.

Looking forward, I plan to continue refining this structured yet flexible approach. I want to place even greater emphasis on tools like pseudocode and modeling to better visualize system behavior before development begins. Additionally, I aim to enhance my ability to anticipate user experience challenges early in the design process, since user satisfaction is ultimately the best measure of success. By combining careful planning, clear communication, and iterative design practices, I am confident that I can continue to deliver high-quality software solutions that not only meet client requirements but also provide long-term value.
